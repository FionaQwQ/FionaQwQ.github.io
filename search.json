[{"title":"this","url":"/2019/12/25/this/","content":"\n### this简介\n\nthis是在**运行时**进行**绑定**的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。\nthis的绑定和函数声明的位置没有任何关系，只**取决于函数的调用方式/位置**。\n调用位置就是函数在代码中被调用的位置，而不是声明的位置。\n使用开发者工具开发者工具得到调用栈call stack（通过设置断点或者插入debugger）,然后找到栈中的第二个元素，就是真正的调用位置。\n\nthis提供了一种更优雅的方式来“传递”一个对象引用，因此可以将API设计得更加简洁并且易于复用。\n\nthis在任何情况下都不指向函数的词法作用域。\n在JS内部，作用域确实和对象类似，可见的标识符都是它的属性。\n但是作用域“对象”无法通过JS代码访问，它存在于JS引擎内部。\n\n### 默认绑定\n\n```javascript\nfunction foo() {\n    console.log( this.a )\n}\n\nvar a = 2\n\nfoo() //2\n\n ```\n在本例中，函数调用时是直接使用不带任何修饰的函数引用进行调用的，因此应用了this的默认绑定，因此**this指向全局对象**。\n而声明在全局作用域中的变量就是全局对象的一个同名属性，它们本质上是一个东西。\n如果使用严格模式，则不能将全局对象用于默认绑定，因此this会绑定在undefined。\n\n```javascript\nfunction foo() {\n    \"use strict\";\n    console.log( this.a )\n}\n\nvar a = 2;\n\nfoo(); //TypeError: this is undefined\n```\n\n需要注意的是，虽然this的绑定规则完全取决于调用位置，但是若foo()运行在非严格模式下，而调用foo()在严格模式下， 则不影响this默认绑定到全局变量：\n\n```javascript\nfunction foo() {\n    console.log( this.a );\n}\n\nvar a = 2;\n\n(function() {\n    \"use strict\";\n     foo(); // 2\n})();\n```\n\n### 隐式绑定\n\n```javascript\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2,\n    foo: foo\n};\n\nobj.foo() // 2\n```\n无论是直接在obj中定义还是先定义再添加为引用属性，这个函数严格来说都不属于obj对象。然而调用位置会使用obj上下文来引用函数，因此你可以说函数被调用时obj对象“拥有”或者“包含”函数引用。\n\n当函数引用时有上下文对象，隐式绑定会将函数调用中的this绑定到这个上下文对象。\n\n对象属性引用链中只有上一层或者说最后一层在调用位置中起作用：\n\n```javascript\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj2 = {\n    a: 42,\n    foo: foo\n}\n\nvar obj1 = {\n    a: 2,\n    obj2: obj2\n}\n\nobj1.obj2.foo(); // 42\n```\n\n隐式丢失：\n一个最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把this绑定到全局对象或者undefined上（取决于是否是严格模式）\n\n```javascript\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2,\n    foo: foo\n}\n\nvar bar = obj.foo\n\nvar a = \"oops, global\"\n\nbar() //\"oops,global\"\n```\n虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。\n一种更出乎意料的情况发生在传入回调函数时：\n\n```javascript\nfunction foo() {\n    console.log( this.a )\n}\n\nfunction doFoo(fn) {\n    //fn其实引用的是foo\n    fn() //  <-- 调用位置\n}\n\nvar obj = {\n    a: 2,\n    foo: foo\n}\n\nvar a = \"oops,global\" \n\ndoFoo(obj.foo) //\"oops,global\"\n```\n\n**参数传递其实就是一种隐式赋值**，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。\n如果把函数传入语言内置的函数而不是传入自己声明的函数，结果是一样的：\n\n```javascript\nfunction foo() {\n    console.log( this.a )\n}\n\nvar obj = {\n    a: 2,\n    foo: foo\n}\n\nvar  a = \"oops,global\"\n\nsetTimeout( obj.foo, 100 ) //\"oops, global\"\n```\n所以回调函数丢失this绑定是很常见的，之后会说如何通过固定this来修复这个问题。\n\n### 显式绑定\n\n隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上。\n如何在某个对象上强制调用函数。\n\n可以使用函数的*call*和*apply*方法。\nJS提供的绝大多数函数以及你自己创建的所有函数都可以使用*call*和*apply*方法\n\n它们的第一个参数是一个对象，是给this准备的，在调用函数时可以将这个设置的对象绑定到this。\n```javascript\nfunction foo() {\n    console.log( this.a )\n}\n\nvar obj = {\n    a: 2\n}\n\nfoo.call( obj ) // 2   在调用foo的时候把它的this强制绑定到obj上\n```\n如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作this的绑定对象，这个原始值会被转换成它的对象形式（也就是new String(..) new Boolean(...)或者new Number(..)）。这通常被称为“装箱”。\n\n从this绑定的角度来说，call和apply是一样的，它们的区别在其他参数上。\n\n显式绑定仍然无法解决之前提到的绑定丢失的问题，但是显式绑定的一个变种可以解决这个问题：\n**硬绑定**\n```javascript\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a:2\n}\n\nvar bar = function() {\n    foo.call( obj );\n}\n\nbar() //2\nsetTimeout( bar, 100) //2\n\n//硬绑定的bar不可能再修改它的this\nbar.call( window ) //2\n```\n\n无论之后如何调用函数bar，它总会手动在obj上调用foo。这种绑定是一种显式地强制绑定，因此我们称之为硬绑定。\n硬绑定的典型应用场景就是创建一个包裹函数，负责接收参数并返回值：\n```javascript\nfunction foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n}\n\nvar obj = {\n    a:2\n}\n\nvar bar = function() {\n    return foo.apply( obj, arguments )\n}\n\nvar b = bar( 3 ) // 2 3\nconsole.log( b )// 5\n```\n\n另一种使用方法是创建一个可以重复使用的辅助函数\n```javascript\nfunction foo(something) {\n    console.log(this.a, something)\n    return this.a + something\n}\n\n//简单的辅助绑定函数\nfunction bind(fn, obj) {\n    return function() {\n        return fn.apply( obj, arguments )\n    }\n}\n\nvar obj = {\n    a:2\n}\n\nvar bar = bind( foo, obj )\n\nvar b = bar( 3 ) //2 3\nconsole.log( b ) //5\n```\n由于硬绑定是一种非常常用的模式，所以ES5提供了内置的方法*Function.prototype.bind*：\n```javascript\nfunction foo(something) {\n    console.log( this.a + something )\n    return this.a + something\n}\n\nvar obj = {\n    a:2\n}\n\nvar bar = foo.bind( obj )\n\nvar b = bar( 3 ) // 2 3\nconsole.log( b ) //5\n```\n\n*bind(..)*会返回一个硬编码的新函数，它会把你指定的参数设置为this的上下文并调用原始函数\n\n第三方库的许多函数，以及JS语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文context”，其作用和bind(..)一样，确保你的回调函数使用指定的this：\n```javascript\nfunction foo(el) {\n    console.log( el, this.id )\n}\n\nvar obj = {\n    id: \"awesome\"\n}\n\n//调用foo(..)时把this绑定到obj\n[1,2,3].forEach(foo, obj)\n// 1 awesome 2 awesome 3 awesome\n```\n\n这些函数实际上就是通过*call*或者*apply*实现了显式绑定。\n\n\n\n\n\n","tags":["javascript"],"categories":["javascript"]},{"title":"我梦见你梦见我","url":"/2019/12/25/hello-world/","content":"\n\n<center>梦里的时间总觉得长</center>\n<center>不过是一刹那</center>\n<center>却总以为是天长地久</center>\n<center>好像彼此认识了许多年</center>\n<center>原来都不算数的</center> \n"},{"title":"categories","url":"/categories/index.html"},{"title":"tags","url":"/tags/index.html"}]